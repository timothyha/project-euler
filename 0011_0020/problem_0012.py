# https://projecteuler.net/problem=12
# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# Let us list the factors of the first seven triangle numbers:
#      1: 1
#     3: 1,3
#     6: 1,2,3,6
#    10: 1,2,5,10
#    15: 1,3,5,15
#    21: 1,3,7,21
#    28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
# What is the value of the first triangle number to have over five hundred divisors?

# some reasoning: if N is a product of p^n and q^k, it will be divisible by (n+1) * (k+1) ...

# populating list of primes, using problem 10's algorithm
primes = list([2])
maxnum = 1000000
# populating the sieve of Eratosthenes - http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
sieve = set([2])
for i in range(2,maxnum/2+1):
    sieve.add(2*i)
n = 3
while n <= maxnum:
    if n not in sieve:
        primes.append(n)
        for k in range(1,maxnum/n+1):
            sieve.add(n*k)
        #print n
    n = n+2 # loop further on odd numbers only

print "Primes count = ", len(primes)
    
saved_layouts = [];
    
def prime_layout(n):
    global primes
    global saved_layouts # to speed up things, we save intermediary results    
    
    if n < len(saved_layouts):
        print "using cache for", n
        return saved_layouts[n-1]
        
    if n in primes:
        listprimes = list([n])
        listpowers = list([1])
        if len(saved_layouts) == n-1:
            saved_layouts.append(list([listprimes, listpowers]))
        return list([listprimes, listpowers])
    
    listprimes = []
    listpowers = []
    
    length = len(primes)
    for i in range(0,length):
        if primes[i] >= n:
            break;
        if n % primes[i] == 0:
            power = 1
            k = primes[i] * primes[i]
            while n % k == 0:
                power = power + 1
                k = k * primes[i]

            listprimes.append(primes[i])
            listpowers.append(power)
            
    if len(saved_layouts) == n-1:
        saved_layouts.append(list([listprimes, listpowers]))
    return list([listprimes, listpowers])

# N and N+1 never have same common prime divisor, so this N(N+1)/2 is sum of count_primes and probably minus 1  

def count_divisors(n):

    prime1 = prime_layout(n)
    listprimes1 = prime1[0];
    listpowers1 = prime1[1];
    
    prime2 = prime_layout(n+1)
    listprimes2 = prime2[0];
    listpowers2 = prime2[1];
    
    # n * (n+1) /2, so we remove 2 from list of primes
    
    if listprimes1[0] == 2:
        if listpowers1[0] < 2:
            listprimes1.pop(0)
            listpowers1.pop(0)
        else:
            listpowers1[0] = listpowers1[0] - 1
            
    if listprimes2[0] == 2:
        if listpowers2[0] < 2:
            listprimes2.pop(0)
            listpowers2.pop(0)
        else:
            listpowers2[0] = listpowers2[0] - 1
            
    result = 1
    for i in range(0, len(listpowers1)):
        result = result * (listpowers1[i] + 1)
    for i in range(0, len(listpowers2)):
        result = result * (listpowers2[i] + 1)
    return result

# to populate the saved_layouts list
print prime_layout(1)
print prime_layout(2)
print prime_layout(3)

n = 3
while n > 1:
    c = count_divisors(n)
    print n, c
    if c > 500:
        print "Required triangle number =", (n*(n+1))/2
        print prime_layout((n*(n+1))/2)
        break
    n = n+1
    
# 12375 576
# layout is [[2, 3, 5, 7, 11, 13, 17], [2, 2, 3, 1, 1, 1, 1]]    
# triangle number = 76576500
    